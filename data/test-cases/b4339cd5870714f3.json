{
  "uid" : "b4339cd5870714f3",
  "name" : "test_tear_down",
  "fullName" : "basic_test#test_tear_down",
  "historyId" : "b779a260a1e2fa9cd36f6509dac5ddee",
  "time" : {
    "start" : 1663675911888,
    "stop" : 1663675918574,
    "duration" : 6686
  },
  "status" : "broken",
  "statusMessage" : "pydrive.auth.RefreshError: Access token refresh failed: invalid_grant: Token has been expired or revoked.",
  "statusTrace" : "self = <pydrive.auth.GoogleAuth object at 0x000002339AFC89D0>\n\n    def Refresh(self):\n      \"\"\"Refreshes the access_token.\n    \n      :raises: RefreshError\n      \"\"\"\n      if self.credentials is None:\n        raise RefreshError('No credential to refresh.')\n      if self.credentials.refresh_token is None:\n        raise RefreshError('No refresh_token found.'\n                           'Please set access_type of OAuth to offline.')\n      if self.http is None:\n        self.http = httplib2.Http(timeout=self.http_timeout)\n      try:\n>       self.credentials.refresh(self.http)\n\nc:\\users\\user\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pydrive\\auth.py:475: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <oauth2client.client.OAuth2Credentials object at 0x000002339B000940>, http = <httplib2.Http object at 0x000002339B0006D0>\n\n    def refresh(self, http):\n        \"\"\"Forces a refresh of the access_token.\n    \n        Args:\n            http: httplib2.Http, an http object to be used to make the refresh\n                  request.\n        \"\"\"\n>       self._refresh(http)\n\nc:\\users\\user\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\oauth2client\\client.py:545: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <oauth2client.client.OAuth2Credentials object at 0x000002339B000940>, http = <httplib2.Http object at 0x000002339B0006D0>\n\n    def _refresh(self, http):\n        \"\"\"Refreshes the access_token.\n    \n        This method first checks by reading the Storage object if available.\n        If a refresh is still needed, it holds the Storage lock until the\n        refresh is completed.\n    \n        Args:\n            http: an object to be used to make HTTP requests.\n    \n        Raises:\n            HttpAccessTokenRefreshError: When the refresh fails.\n        \"\"\"\n        if not self.store:\n            self._do_refresh_request(http)\n        else:\n            self.store.acquire_lock()\n            try:\n                new_cred = self.store.locked_get()\n    \n                if (new_cred and not new_cred.invalid and\n                        new_cred.access_token != self.access_token and\n                        not new_cred.access_token_expired):\n                    logger.info('Updated access_token read from Storage')\n                    self._updateFromCredential(new_cred)\n                else:\n>                   self._do_refresh_request(http)\n\nc:\\users\\user\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\oauth2client\\client.py:761: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <oauth2client.client.OAuth2Credentials object at 0x000002339B000940>, http = <httplib2.Http object at 0x000002339B0006D0>\n\n    def _do_refresh_request(self, http):\n        \"\"\"Refresh the access_token using the refresh_token.\n    \n        Args:\n            http: an object to be used to make HTTP requests.\n    \n        Raises:\n            HttpAccessTokenRefreshError: When the refresh fails.\n        \"\"\"\n        body = self._generate_refresh_request_body()\n        headers = self._generate_refresh_request_headers()\n    \n        logger.info('Refreshing access_token')\n        resp, content = transport.request(\n            http, self.token_uri, method='POST',\n            body=body, headers=headers)\n        content = _helpers._from_bytes(content)\n        if resp.status == http_client.OK:\n            d = json.loads(content)\n            self.token_response = d\n            self.access_token = d['access_token']\n            self.refresh_token = d.get('refresh_token', self.refresh_token)\n            if 'expires_in' in d:\n                delta = datetime.timedelta(seconds=int(d['expires_in']))\n                self.token_expiry = delta + _UTCNOW()\n            else:\n                self.token_expiry = None\n            if 'id_token' in d:\n                self.id_token = _extract_id_token(d['id_token'])\n                self.id_token_jwt = d['id_token']\n            else:\n                self.id_token = None\n                self.id_token_jwt = None\n            # On temporary refresh errors, the user does not actually have to\n            # re-authorize, so we unflag here.\n            self.invalid = False\n            if self.store:\n                self.store.locked_put(self)\n        else:\n            # An {'error':...} response body means the token is expired or\n            # revoked, so we flag the credentials as such.\n            logger.info('Failed to retrieve access token: %s', content)\n            error_msg = 'Invalid response {0}.'.format(resp.status)\n            try:\n                d = json.loads(content)\n                if 'error' in d:\n                    error_msg = d['error']\n                    if 'error_description' in d:\n                        error_msg += ': ' + d['error_description']\n                    self.invalid = True\n                    if self.store is not None:\n                        self.store.locked_put(self)\n            except (TypeError, ValueError):\n                pass\n>           raise HttpAccessTokenRefreshError(error_msg, status=resp.status)\nE           oauth2client.client.HttpAccessTokenRefreshError: invalid_grant: Token has been expired or revoked.\n\nc:\\users\\user\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\oauth2client\\client.py:819: HttpAccessTokenRefreshError\n\nDuring handling of the above exception, another exception occurred:\n\n    def test_tear_down():\n>       finish_test()\n\nbasic_test.py:280: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nutills\\drivers.py:90: in finish_test\n    gdrive.upload_test_video(file_name=f\"{test_video_file_name}.mp4\")\nutills\\gdrive\\gdrive.py:7: in upload_test_video\n    gauth.LocalWebserverAuth()\nc:\\users\\user\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pydrive\\auth.py:120: in _decorated\n    self.Refresh()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pydrive.auth.GoogleAuth object at 0x000002339AFC89D0>\n\n    def Refresh(self):\n      \"\"\"Refreshes the access_token.\n    \n      :raises: RefreshError\n      \"\"\"\n      if self.credentials is None:\n        raise RefreshError('No credential to refresh.')\n      if self.credentials.refresh_token is None:\n        raise RefreshError('No refresh_token found.'\n                           'Please set access_type of OAuth to offline.')\n      if self.http is None:\n        self.http = httplib2.Http(timeout=self.http_timeout)\n      try:\n        self.credentials.refresh(self.http)\n      except AccessTokenRefreshError as error:\n>       raise RefreshError('Access token refresh failed: %s' % error)\nE       pydrive.auth.RefreshError: Access token refresh failed: invalid_grant: Token has been expired or revoked.\n\nc:\\users\\user\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pydrive\\auth.py:477: RefreshError",
  "flaky" : false,
  "newFailed" : false,
  "newBroken" : false,
  "newPassed" : false,
  "retriesCount" : 0,
  "retriesStatusChange" : false,
  "beforeStages" : [ ],
  "testStage" : {
    "status" : "broken",
    "statusMessage" : "pydrive.auth.RefreshError: Access token refresh failed: invalid_grant: Token has been expired or revoked.",
    "statusTrace" : "self = <pydrive.auth.GoogleAuth object at 0x000002339AFC89D0>\n\n    def Refresh(self):\n      \"\"\"Refreshes the access_token.\n    \n      :raises: RefreshError\n      \"\"\"\n      if self.credentials is None:\n        raise RefreshError('No credential to refresh.')\n      if self.credentials.refresh_token is None:\n        raise RefreshError('No refresh_token found.'\n                           'Please set access_type of OAuth to offline.')\n      if self.http is None:\n        self.http = httplib2.Http(timeout=self.http_timeout)\n      try:\n>       self.credentials.refresh(self.http)\n\nc:\\users\\user\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pydrive\\auth.py:475: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <oauth2client.client.OAuth2Credentials object at 0x000002339B000940>, http = <httplib2.Http object at 0x000002339B0006D0>\n\n    def refresh(self, http):\n        \"\"\"Forces a refresh of the access_token.\n    \n        Args:\n            http: httplib2.Http, an http object to be used to make the refresh\n                  request.\n        \"\"\"\n>       self._refresh(http)\n\nc:\\users\\user\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\oauth2client\\client.py:545: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <oauth2client.client.OAuth2Credentials object at 0x000002339B000940>, http = <httplib2.Http object at 0x000002339B0006D0>\n\n    def _refresh(self, http):\n        \"\"\"Refreshes the access_token.\n    \n        This method first checks by reading the Storage object if available.\n        If a refresh is still needed, it holds the Storage lock until the\n        refresh is completed.\n    \n        Args:\n            http: an object to be used to make HTTP requests.\n    \n        Raises:\n            HttpAccessTokenRefreshError: When the refresh fails.\n        \"\"\"\n        if not self.store:\n            self._do_refresh_request(http)\n        else:\n            self.store.acquire_lock()\n            try:\n                new_cred = self.store.locked_get()\n    \n                if (new_cred and not new_cred.invalid and\n                        new_cred.access_token != self.access_token and\n                        not new_cred.access_token_expired):\n                    logger.info('Updated access_token read from Storage')\n                    self._updateFromCredential(new_cred)\n                else:\n>                   self._do_refresh_request(http)\n\nc:\\users\\user\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\oauth2client\\client.py:761: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <oauth2client.client.OAuth2Credentials object at 0x000002339B000940>, http = <httplib2.Http object at 0x000002339B0006D0>\n\n    def _do_refresh_request(self, http):\n        \"\"\"Refresh the access_token using the refresh_token.\n    \n        Args:\n            http: an object to be used to make HTTP requests.\n    \n        Raises:\n            HttpAccessTokenRefreshError: When the refresh fails.\n        \"\"\"\n        body = self._generate_refresh_request_body()\n        headers = self._generate_refresh_request_headers()\n    \n        logger.info('Refreshing access_token')\n        resp, content = transport.request(\n            http, self.token_uri, method='POST',\n            body=body, headers=headers)\n        content = _helpers._from_bytes(content)\n        if resp.status == http_client.OK:\n            d = json.loads(content)\n            self.token_response = d\n            self.access_token = d['access_token']\n            self.refresh_token = d.get('refresh_token', self.refresh_token)\n            if 'expires_in' in d:\n                delta = datetime.timedelta(seconds=int(d['expires_in']))\n                self.token_expiry = delta + _UTCNOW()\n            else:\n                self.token_expiry = None\n            if 'id_token' in d:\n                self.id_token = _extract_id_token(d['id_token'])\n                self.id_token_jwt = d['id_token']\n            else:\n                self.id_token = None\n                self.id_token_jwt = None\n            # On temporary refresh errors, the user does not actually have to\n            # re-authorize, so we unflag here.\n            self.invalid = False\n            if self.store:\n                self.store.locked_put(self)\n        else:\n            # An {'error':...} response body means the token is expired or\n            # revoked, so we flag the credentials as such.\n            logger.info('Failed to retrieve access token: %s', content)\n            error_msg = 'Invalid response {0}.'.format(resp.status)\n            try:\n                d = json.loads(content)\n                if 'error' in d:\n                    error_msg = d['error']\n                    if 'error_description' in d:\n                        error_msg += ': ' + d['error_description']\n                    self.invalid = True\n                    if self.store is not None:\n                        self.store.locked_put(self)\n            except (TypeError, ValueError):\n                pass\n>           raise HttpAccessTokenRefreshError(error_msg, status=resp.status)\nE           oauth2client.client.HttpAccessTokenRefreshError: invalid_grant: Token has been expired or revoked.\n\nc:\\users\\user\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\oauth2client\\client.py:819: HttpAccessTokenRefreshError\n\nDuring handling of the above exception, another exception occurred:\n\n    def test_tear_down():\n>       finish_test()\n\nbasic_test.py:280: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nutills\\drivers.py:90: in finish_test\n    gdrive.upload_test_video(file_name=f\"{test_video_file_name}.mp4\")\nutills\\gdrive\\gdrive.py:7: in upload_test_video\n    gauth.LocalWebserverAuth()\nc:\\users\\user\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pydrive\\auth.py:120: in _decorated\n    self.Refresh()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pydrive.auth.GoogleAuth object at 0x000002339AFC89D0>\n\n    def Refresh(self):\n      \"\"\"Refreshes the access_token.\n    \n      :raises: RefreshError\n      \"\"\"\n      if self.credentials is None:\n        raise RefreshError('No credential to refresh.')\n      if self.credentials.refresh_token is None:\n        raise RefreshError('No refresh_token found.'\n                           'Please set access_type of OAuth to offline.')\n      if self.http is None:\n        self.http = httplib2.Http(timeout=self.http_timeout)\n      try:\n        self.credentials.refresh(self.http)\n      except AccessTokenRefreshError as error:\n>       raise RefreshError('Access token refresh failed: %s' % error)\nE       pydrive.auth.RefreshError: Access token refresh failed: invalid_grant: Token has been expired or revoked.\n\nc:\\users\\user\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pydrive\\auth.py:477: RefreshError",
    "steps" : [ ],
    "attachments" : [ {
      "uid" : "7674ff212d0c9034",
      "name" : "stdout",
      "source" : "7674ff212d0c9034.txt",
      "type" : "text/plain",
      "size" : 20
    } ],
    "parameters" : [ ],
    "attachmentsCount" : 1,
    "shouldDisplayMessage" : true,
    "hasContent" : true,
    "stepsCount" : 0
  },
  "afterStages" : [ ],
  "labels" : [ {
    "name" : "suite",
    "value" : "basic_test"
  }, {
    "name" : "host",
    "value" : "DESKTOP-S8ODV3K"
  }, {
    "name" : "thread",
    "value" : "37880-MainThread"
  }, {
    "name" : "framework",
    "value" : "pytest"
  }, {
    "name" : "language",
    "value" : "cpython3"
  }, {
    "name" : "package",
    "value" : "basic_test"
  }, {
    "name" : "resultFormat",
    "value" : "allure2"
  } ],
  "parameters" : [ ],
  "links" : [ ],
  "hidden" : true,
  "retry" : true,
  "extra" : {
    "categories" : [ ],
    "tags" : [ ]
  },
  "source" : "b4339cd5870714f3.json",
  "parameterValues" : [ ]
}